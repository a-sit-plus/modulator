<div align="center">

<img alt="modulator – compileOnly Kotlin Multiplatform Dependencies without Dependency Hell" src="modulator.png">

# modulator – `compileOnly` Kotlin Multiplatform Dependencies without Dependency Hell

[![A-SIT Plus Official](https://img.shields.io/badge/A--SIT_Plus-official-005b79?logo=data%3Aimage%2Fsvg%2Bxml%3Bbase64%2CPHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNDMuNzYyODYgMTg0LjgxOTk5Ij48ZGVmcz48Y2xpcFBhdGggaWQ9ImEiIGNsaXBQYXRoVW5pdHM9InVzZXJTcGFjZU9uVXNlIj48cGF0aCBkPSJNMCA1OTUuMjhoODQxLjg5VjBIMFoiLz48L2NsaXBQYXRoPjwvZGVmcz48ZyBjbGlwLXBhdGg9InVybCgjYSkiIHRyYW5zZm9ybT0ibWF0cml4KDEuMzMzMzMzMyAwIDAgLTEuMzMzMzMzMyAtNDgyLjI1IDUxNy41MykiPjxwYXRoIGZpbGw9IiMwMDViNzkiIGQ9Ik00MTUuNjcgMjQ5LjUzYy03LjE1LjA4LTEzLjk0IDEtMjAuMTcgMi43NWE1Mi4zMyA1Mi4zMyAwIDAgMC0xNy40OCA4LjQ2IDQwLjQzIDQwLjQzIDAgMCAwLTExLjk2IDE0LjU2Yy0yLjY4IDUuNDEtNC4xNCAxMS44NC00LjM1IDE5LjA5bC0uMDIgNi4xMnYyLjE3YS43MS43MSAwIDAgMCAuNy43M2gxNi41MmMuMzkgMCAuNy0uMzIuNzEtLjdsLjAxLTIuMmMwLTIuNi4wMi01LjgyLjAzLTYuMDcuMi00LjYgMS4yNC04LjY2IDMuMDgtMTIuMDZhMjguNTIgMjguNTIgMCAwIDEgOC4yMy05LjU4IDM1LjI1IDM1LjI1IDAgMCAxIDExLjk2LTUuNTggNTUuMzggNTUuMzggMCAwIDEgMTIuNTgtMS43NmM0LjMyLjEgOC42LjcgMTIuNzQgMS44YTM1LjA3IDM1LjA3IDAgMCAxIDExLjk2IDUuNTcgMjguNTQgMjguNTQgMCAwIDEgOC4yNCA5LjU3YzEuOTYgMy42NCAzIDguMDIgMy4xMiAxMy4wMnYyNC4wOUgzNjIuNGEuNy43IDAgMCAwLS43MS43VjMzNWMwIDguNDMuMDEgOC4wNS4wMSA4LjE0LjIgNy4zIDEuNjcgMTMuNzcgNC4zNiAxOS4yMmE0MC40MyA0MC40MyAwIDAgMCAxMS45NiAxNC41N2M1IDMuNzYgMTAuODcgNi42MSAxNy40OCA4LjQ2YTc3LjUgNzcuNSAwIDAgMCAyMC4wMiAyLjc3YzcuMTUtLjA3IDEzLjk0LTEgMjAuMTctMi43NGE1Mi4zIDUyLjMgMCAwIDAgMTcuNDgtOC40NiA0MC40IDQwLjQgMCAwIDAgMTEuOTUtMTQuNTdjMS42Mi0zLjI2IDMuNzctMTAuMDQgMy43Ny0xNC42OCAwLS4zOC0uMTctLjc0LS41NC0uODJsLTE2Ljg5LS40Yy0uMi0uMDQtLjM0LjM0LS4zNC41NCAwIC4yNy0uMDMuNC0uMDYuNi0uNSAyLjgyLTEuMzggNS40LTIuNjEgNy42OWEyOC41MyAyOC41MyAwIDAgMS04LjI0IDkuNTggMzUuMDEgMzUuMDEgMCAwIDEtMTEuOTYgNS41NyA1NS4yNSA1NS4yNSAwIDAgMS0xMi41NyAxLjc3Yy00LjMyLS4xLTguNjEtLjcxLTEyLjc1LTEuOGEzNS4wNSAzNS4wNSAwIDAgMS0xMS45Ni01LjU3IDI4LjUyIDI4LjUyIDAgMCAxLTguMjMtOS41OGMtMS44Ni0zLjQ0LTIuOS03LjU1LTMuMDktMTIuMmwtLjAxLTcuNDdoODkuMTZhLjcuNyAwIDAgMCAuNy0uNzJ2LTM5LjVjLS4xLTcuNjUtMS41OC0xNC40LTQuMzgtMjAuMDZhNDAuNCA0MC40IDAgMCAwLTExLjk1LTE0LjU2IDUyLjM3IDUyLjM3IDAgMCAwLTE3LjQ4LTguNDcgNzcuNTYgNzcuNTYgMCAwIDAtMjAuMDEtMi43N1oiLz48cGF0aCBmaWxsPSIjY2U0OTJlIiBkPSJNNDE5LjM4IDI4MC42M2gtNy41N2EuNy43IDAgMCAwLS43MS43MXYxNS40MmE4LjE3IDguMTcgMCAwIDAtMy43OCA2LjkgOC4yOCA4LjI4IDAgMCAwIDE2LjU0IDAgOC4yOSA4LjI5IDAgMCAwLTMuNzYtNi45di0xNS40MmEuNy43IDAgMCAwLS43Mi0uNzEiLz48L2c%2BPC9zdmc%2B&logoColor=white&labelColor=white)](https://a-sit-plus.github.io)
[![GitHub license](https://img.shields.io/badge/license-Apache%20License%202.0-brightgreen.svg?style=flat)](http://www.apache.org/licenses/LICENSE-2.0)


**_modulator_ - a lean Gradle plugin that gives Kotlin Multiplatform the superpower of JVM-style `compileOnly` dependencies! No bloat, no dirty tricks, just clean, modular APIs, and full toolchain compatibility – forever!**


</div>

Imagine a Spring Boot core with optional persistence: JPA/Hibernate or MongoDB. You want expressive extension functions
like `Order.toJpaEntity()` or `Order.toMongoDocument()` to become available automatically when the corresponding starter
is on the classpath, without forcing every service to depend on both stacks.  
On the JVM you’d create these adapters using `compileOnly` dependencies on JPA/Hibernate and MongoDB to keep your core clean.
Unfortunately, _Kotlin Multiplatform says no!_  
Hence, optional, extension‑driven integrations either bloat dependency graphs or require tedious manual wiring.


Enter _modulator_ – a lean Gradle plugin that brings two complementary capabilities to Kotlin Multiplatform:

1. Piggyback modules with extension functionality and/or glue code on two or more `carrier` modules within a multi-module project.
2. Automatically add those piggybacked modules as dependencies when all of their carriers are present in a consuming project.


Just apply `at.asitplus.gradle.modulator` to any Gradle module that requires either capability.
That’s it – no custom wiring, no dependency clutter, no hacks, no compiler plugins, no code generation,
but full backwards compatibility with all Kotlin and Gradle tooling!


## Quickstart
_modulator_ introduces a new type of dependencies alongside `api`, `implementation`, …, that are available now: `carrier` dependencies.
A bridge / glue module depends on two or more carrier modules (within the same multi-module gradle project).
When all carriers are present in a consumer, the bridge module is automatically pulled in.


### Creating Bridge Modules ("Modulation")
If `bridgeModule` should provide glue functionality between `modA` and `modB`
* apply the `at.asitplus.gradle.modulator` Gradle plugin
* add `modA` and `modB` as `carrier` dependencies:

```kotlin
//build.gradle.kts of bridgeModule

plugins {
    alias(libs.plugins.kotlinMultiplatform)
    `maven-publish`
    /* …… */
    id("at.asitplus.gradle.modulator") version "$moduatorVersion"
}

kotlin {
    listOf(
        iosX64(),
        iosArm64(),
        iosSimulatorArm64()
    ).forEach { iosTarget ->
        iosTarget.binaries.framework {
            baseName = "BridgeModule"
            isStatic = true
        }
    }

    jvm()

    // add additional targets as desired
    
    sourceSets {
        //does not have to be commonMain, but it makes the most sense
        commonMain.dependencies {
           carrier(project(":modA")) //no need to modify modA's buildscript
           carrier(project(":modB")) //no need to modify modB's buildscript
        }
    }
}

//…… publishing, etc.
```

This will add metadata to both `modA` and `modB` publications, such that the published artifacts of both contain the information that
`bridgeModule` should be pulled in when both `modA` and `modB` are added as dependencies to a consuming project.  
The buildscripts of neither `modA` nor `modB` require any changes or even the modulator gradle plugin.

### Automagically Pulling in Bridge Modules ("Demodulation")

_modulator_ works its magic in consuming projects even less obtrusively:
Just apply the modulator Gradle plugin in consumers and the carrier dependencies as regular `api` or `implementation` dependencies.
No other changes are required to the buildscript.

```kotlin
//build.gradle.kts of consuming project
plugins {
    alias(libs.plugins.kotlinMultiplatform)
    id("at.asitplus.gradle.modulator") version "$modulatorVersion"
}

kotlin {
    listOf(
        iosX64(),
        iosArm64(),
        iosSimulatorArm64()
    ).forEach { iosTarget ->
        iosTarget.binaries.framework {
            baseName = "ComposeApp"
            isStatic = true
        }
    }

    jvm()
    
    // add additional targets as desired
    
    sourceSets {
        commonMain.dependencies {
            api("com.example.modA:$modAversion")
            api("com.example.modB:$modBversion")
            //that's it! bridgeModule will be automagically pulled in
        }
    }
}
```

If `modA` and `modB` are added as `api` dependencies, the bridge module will also be added as `api` dependency. The same holds
for `implementation` dependencies.

For library authors, this is not quite as hassle-free as `compileOnly` dependencies on the JVM but:
* The project setup remains fully transparent, predictable, intelligible and easily maintainable.
* The use of dedicated bridge modules and enriched Gradle metadata on carrier modules is fully and perfectly backwards-compatible with the whole Gradle/KMP ecosystem, and it will stay that way.
* Your project either compile or it does not run. No `RuntimeException` or other unpleasant surprises, because everything is known at compile-time.

In the end, no invasive changes to the KMP/Gradle tooling are required, as _modulator_ simply adds additional dependencies in the same way as adding them explicitly yourself.

## Concrete Example Projects
The `example` directory contains two projects that showcase _modulator_:
1. `modulatingProducer` contains three modules:
   1. `cose` providing a single sample COSE-ish data class
   2. `jose` providing a single sample JOSE-ish data class
   3. `coseToJose` providing mapper functionality from COSE to JOSE
2. `modulatedConsumer` contains a single module that adds `cose` and `jose` dependencies and uses the mapping functionality provided by `cosetoJose`, showcasing that no explicit adding of this dependency is needed

To try it out: publish `modulatingProduce` to maven local and open `mulatedConsumer` in IDEA to witness the magic!

---

<p align="center">
The Apache License does not apply to the logos, (including the A-SIT logo) and the project/module name(s), as these are the sole property of
A-SIT/A-SIT Plus GmbH and may not be used in derivative works without explicit permission!
</p>
