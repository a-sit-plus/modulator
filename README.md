<div align="center">

<img alt="modulator – CompileOnly Kotlin Multiplatform Dependencies without Dependency Hell" src="modulator.png">

# modulator – `compileOnly` Kotlin Multiplatform Dependencies without Dependency Hell

[![A-SIT Plus Official](https://img.shields.io/badge/A--SIT_Plus-official-005b79?logo=data%3Aimage%2Fsvg%2Bxml%3Bbase64%2CPHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNDMuNzYyODYgMTg0LjgxOTk5Ij48ZGVmcz48Y2xpcFBhdGggaWQ9ImEiIGNsaXBQYXRoVW5pdHM9InVzZXJTcGFjZU9uVXNlIj48cGF0aCBkPSJNMCA1OTUuMjhoODQxLjg5VjBIMFoiLz48L2NsaXBQYXRoPjwvZGVmcz48ZyBjbGlwLXBhdGg9InVybCgjYSkiIHRyYW5zZm9ybT0ibWF0cml4KDEuMzMzMzMzMyAwIDAgLTEuMzMzMzMzMyAtNDgyLjI1IDUxNy41MykiPjxwYXRoIGZpbGw9IiMwMDViNzkiIGQ9Ik00MTUuNjcgMjQ5LjUzYy03LjE1LjA4LTEzLjk0IDEtMjAuMTcgMi43NWE1Mi4zMyA1Mi4zMyAwIDAgMC0xNy40OCA4LjQ2IDQwLjQzIDQwLjQzIDAgMCAwLTExLjk2IDE0LjU2Yy0yLjY4IDUuNDEtNC4xNCAxMS44NC00LjM1IDE5LjA5bC0uMDIgNi4xMnYyLjE3YS43MS43MSAwIDAgMCAuNy43M2gxNi41MmMuMzkgMCAuNy0uMzIuNzEtLjdsLjAxLTIuMmMwLTIuNi4wMi01LjgyLjAzLTYuMDcuMi00LjYgMS4yNC04LjY2IDMuMDgtMTIuMDZhMjguNTIgMjguNTIgMCAwIDEgOC4yMy05LjU4IDM1LjI1IDM1LjI1IDAgMCAxIDExLjk2LTUuNTggNTUuMzggNTUuMzggMCAwIDEgMTIuNTgtMS43NmM0LjMyLjEgOC42LjcgMTIuNzQgMS44YTM1LjA3IDM1LjA3IDAgMCAxIDExLjk2IDUuNTcgMjguNTQgMjguNTQgMCAwIDEgOC4yNCA5LjU3YzEuOTYgMy42NCAzIDguMDIgMy4xMiAxMy4wMnYyNC4wOUgzNjIuNGEuNy43IDAgMCAwLS43MS43VjMzNWMwIDguNDMuMDEgOC4wNS4wMSA4LjE0LjIgNy4zIDEuNjcgMTMuNzcgNC4zNiAxOS4yMmE0MC40MyA0MC40MyAwIDAgMCAxMS45NiAxNC41N2M1IDMuNzYgMTAuODcgNi42MSAxNy40OCA4LjQ2YTc3LjUgNzcuNSAwIDAgMCAyMC4wMiAyLjc3YzcuMTUtLjA3IDEzLjk0LTEgMjAuMTctMi43NGE1Mi4zIDUyLjMgMCAwIDAgMTcuNDgtOC40NiA0MC40IDQwLjQgMCAwIDAgMTEuOTUtMTQuNTdjMS42Mi0zLjI2IDMuNzctMTAuMDQgMy43Ny0xNC42OCAwLS4zOC0uMTctLjc0LS41NC0uODJsLTE2Ljg5LS40Yy0uMi0uMDQtLjM0LjM0LS4zNC41NCAwIC4yNy0uMDMuNC0uMDYuNi0uNSAyLjgyLTEuMzggNS40LTIuNjEgNy42OWEyOC41MyAyOC41MyAwIDAgMS04LjI0IDkuNTggMzUuMDEgMzUuMDEgMCAwIDEtMTEuOTYgNS41NyA1NS4yNSA1NS4yNSAwIDAgMS0xMi41NyAxLjc3Yy00LjMyLS4xLTguNjEtLjcxLTEyLjc1LTEuOGEzNS4wNSAzNS4wNSAwIDAgMS0xMS45Ni01LjU3IDI4LjUyIDI4LjUyIDAgMCAxLTguMjMtOS41OGMtMS44Ni0zLjQ0LTIuOS03LjU1LTMuMDktMTIuMmwtLjAxLTcuNDdoODkuMTZhLjcuNyAwIDAgMCAuNy0uNzJ2LTM5LjVjLS4xLTcuNjUtMS41OC0xNC40LTQuMzgtMjAuMDZhNDAuNCA0MC40IDAgMCAwLTExLjk1LTE0LjU2IDUyLjM3IDUyLjM3IDAgMCAwLTE3LjQ4LTguNDcgNzcuNTYgNzcuNTYgMCAwIDAtMjAuMDEtMi43N1oiLz48cGF0aCBmaWxsPSIjY2U0OTJlIiBkPSJNNDE5LjM4IDI4MC42M2gtNy41N2EuNy43IDAgMCAwLS43MS43MXYxNS40MmE4LjE3IDguMTcgMCAwIDAtMy43OCA2LjkgOC4yOCA4LjI4IDAgMCAwIDE2LjU0IDAgOC4yOSA4LjI5IDAgMCAwLTMuNzYtNi45di0xNS40MmEuNy43IDAgMCAwLS43Mi0uNzEiLz48L2c%2BPC9zdmc%2B&logoColor=white&labelColor=white)](https://a-sit-plus.github.io)
[![GitHub license](https://img.shields.io/badge/license-Apache%20License%202.0-brightgreen.svg?style=flat)](http://www.apache.org/licenses/LICENSE-2.0)

</div>

Combining Kotlin's extension functions and `compileOnly` dependencies elevates syntactic sugar to a killer feature for
modular software architecture.
Imagine you have (amongst others) three modules inside a gradle project that that deal with secure communication in a borader sense:
1. Implementation logic for authenticated communication
2. JSON Web Token Data structures (that you pulled out into a separate module for re-usability)
3. CBOR Web Token data structures (because you need to do fancy EUDI stuff)

The first module will contain the crypto implementation (creating and verifying signatures, key management, etc.), while the latter two
are simply data structures that are disjoint, but semantically more or less the same.
* How do you elegantly transform one into the other without forcing a cyclic dependency that would render the modularization rather moot? (Especially if some consumers only need JWT!)
* How do you provide convenience functions such as `JsonWebToken.verify()`, and `CborWebToken.verify()` without having the first module depend on the other two and/or vice versa?

On the JVM, this is easily solved: Add `compileOnly` dependencies on one module inside the other and provide convenience functions and mappings from CWT to JWT as extension functions.
The beauty of this approach is that it neither litters the classpath, nor does it force consumers of your library to manually add some
bridge dependencies that provide such functionality. On the contrary: if both CWT and JWT dependencies are on the classpath
extension functions start to magically appear.

On Kotlin Multiplatform, this is not possible because there is no such thing as a `compileOnly` dependency. This either results
in bloated dependency trees (and hence, bloated libraries and/or executables) or in manually adding bridge dependencies to consuming
projects in addition (or instead) of JWT and CWT dependencies.

<div align="center">

**modulator to the rescue!**

</div>

_modulator_ is a lean Gradle plugin that introduces two features to Kotlin Multiplatform that work in tandem:

1. Create modules inside a multi-module-project that work as a bridge module between two or more other modules inside the project.
2. Automatically add bridge dependencies whenever another projects adds such two or more modules as dependencies

Simply add `at.asitplus.gradle.modulator` to any module that should either have the ability to act as bridge module,
or be able to magically pull in bridge dependencies. That's pretty much all there is to it.

## Creating Bridge Modules
Create a new Gradle module and add the `at.asitplus.gradle.modulator` gradle plugin.
If the new module should provide bridging functionality between `modA` and `modB`, add them as `carrier` dependencies:

```kotlin
//build.gradle.kts of bridgeModule

plugins {
    alias(libs.plugins.kotlinMultiplatform)
    `maven-publish`
    /* …… */
    id("at.asitplus.gradle.modulator") version "$moduatorVersion"
}

kotlin {
    listOf(
        iosX64(),
        iosArm64(),
        iosSimulatorArm64()
    ).forEach { iosTarget ->
        iosTarget.binaries.framework {
            baseName = "BridgeModule"
            isStatic = true
        }
    }

    jvm()

    // add additional targets as desired
    
    sourceSets {
        //does not have to be commonMain, but it makes the most sense
        commonMain.dependencies {
           carrier(project(":modA")) //no need to modify modA'b buildscript
           carrier(project(":modB")) //no need to modify modB's buildscript
        }
    }
}

//…… publishing, etc.
```

This will add metadata to both `modA` and `modB`, such that the published artefacts of both contain the information that
`bridgeModule` should be pulled in when both `modA` and `modB` are added as dependencies to a consuming project.

## Automatically Pulling in Bridge Modules

_modulator_ works its magic in consuming projects even less obtrusively. Simply add the gradle plugin and the modules
that should be augmented with the bridge module's functionality:

```kotlin
//build.gradle.kts of consuming project
plugins {
    alias(libs.plugins.kotlinMultiplatform)
    id("at.asitplus.gradle.modulator") version "$modulatorVersion"
}

kotlin {
    listOf(
        iosX64(),
        iosArm64(),
        iosSimulatorArm64()
    ).forEach { iosTarget ->
        iosTarget.binaries.framework {
            baseName = "ComposeApp"
            isStatic = true
        }
    }

    jvm()
    
    // add additional targets as desired
    
    sourceSets {
        commonMain.dependencies {
            api("com.example.modA:$modAversion")
            api("com.example.modB:$modBversion")
            //that's it! bridgeModule will be automagically pulled in
        }
    }
}
```

If `modA` and `modB` are added as api dependencies, the bridge module will also be added as api dependency. The same holds
for implementation dependencies.

While this is not quite as hassle-free as `compileOnly` dependencies on the JVM, declaring dedicated bridge modules is
perfectly backwards compatible. Hence, consumers are not forced to use _modulator_ but can also opt to manually add such
bridge dependencies. In addition, no invasive changes to the KMP/Gradle tooling are required, as _modulator_ simply adds additional
dependencies in the same way as adding them explicitly yourself.

## Concrete Example Projects
The `example` directory contains two projects that showcase _modulator_:
1. `modulatingProducer` contains three modules:
   1. `cose` providing a single sample COSE-ish data class
   2. `jose` providing a single sample JOSE-ish data class
   3. `coseToJose` providing mapper functionality from COSE to JOSE
2. `modulatedConsumer` contains a single module that adds `cose` and `jose` dependencies and uses the mapping functionality provided by `cosetoJose`, showcasing that no explicit adding of this dependency is needed

To try it out: publish `modulatingProduce` to maven local and open `mulatedConsumer` in IDEA to witness the magic!

---

<p align="center">
The Apache License does not apply to the logos, (including the A-SIT logo) and the project/module name(s), as these are the sole property of
A-SIT/A-SIT Plus GmbH and may not be used in derivative works without explicit permission!
</p>
